(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{369:function(t,s,a){"use strict";a.r(s);var n=a(45),r=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"시작하기"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#시작하기"}},[t._v("#")]),t._v(" 시작하기")]),t._v(" "),a("h2",{attrs:{id:"coroutine"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#coroutine"}},[t._v("#")]),t._v(" Coroutine")]),t._v(" "),a("p",[a("code",[t._v("코루틴")]),t._v(" 이라는 단어는 어디서 나온 단어일까?"),a("br"),t._v("\n이를 알기 위해서는 먼저 "),a("code",[t._v("루틴")]),t._v("이라는 개념을 알아야 한다. "),a("code",[t._v("루틴")]),t._v("은 흔히 말하는 함수라 생각하면 되고, 루틴은"),a("code",[t._v("메인루틴")]),t._v("과 "),a("code",[t._v("서브루틴")]),t._v("으로 나뉘어지는데, 아래 소스를 보면 실행 주체인 "),a("code",[t._v("main()")]),t._v("이 "),a("code",[t._v("메인루틴")]),t._v("이고 호출되는 함수인 "),a("code",[t._v("reverse()")]),t._v("가 "),a("code",[t._v("서브루틴")]),t._v("이 된다.")]),t._v(" "),a("div",{staticClass:"language-kotlin extra-class"},[a("pre",{pre:!0,attrs:{class:"language-kotlin"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fun")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" str "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("reverse")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"asdf"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("println")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("str"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fun")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("reverse")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("str"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" String"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" String"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("println")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"in reverse()"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" str"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("reversed")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[a("code",[t._v("함수")]),t._v("는 "),a("code",[t._v("시작 지점")]),t._v("과 "),a("code",[t._v("끝나는 지점")]),t._v("이 한 곳으로 정해져 있다. 아래 예제를 보면를 보면 getSum() 함수를 호출하며 매개변수로 정수 a, b를 전달한다. 이후 함수 내부에서 두 매개변수를 더한 후 더한 값을 반환한다. 일반적으로 a,b를 전달받고 반환하기 까지 메인스레드는 block 되고 getSum()은 외부요인에 의해 중지되지 않는다.")]),t._v(" "),a("div",{staticClass:"language-kotlin extra-class"},[a("pre",{pre:!0,attrs:{class:"language-kotlin"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fun")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getSum")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Int"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" b "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Int"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Int"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("val")]),t._v(" result "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" a "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" b\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" result\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("코루틴은 서브루틴의 확장된 개념이라고 볼 수 있다. 함수와는 다르게 시작과 끝이 아닌 로직 중간의 어느 부분에서라도 시작과 종료가 이루어질 수 있으며 실행을 일시중지하고 다른 코루틴으로 이동할 수도 있다. 간단한 문법으로 비동기 태스크를 처리할 수 있으며 기존의 스레드를 사용하는 것보다 훨씬 적은 자원을 소비한다.")]),t._v(" "),a("h2",{attrs:{id:"thread-vs-coroutine"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#thread-vs-coroutine"}},[t._v("#")]),t._v(" Thread vs Coroutine")]),t._v(" "),a("h3",{attrs:{id:"thread"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#thread"}},[t._v("#")]),t._v(" Thread")]),t._v(" "),a("ul",[a("li",[t._v("OS의 Native Thread에 직접 링크되어 동작하여 많은 시스템 자원을 사용한다.")]),t._v(" "),a("li",[t._v("Thread간 전환 시에도 CPU의 상태 체크가 필요하므로 그만큼의 비용이 발생한다.")])]),t._v(" "),a("h3",{attrs:{id:"coroutine-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#coroutine-2"}},[t._v("#")]),t._v(" Coroutine")]),t._v(" "),a("ul",[a("li",[t._v("코루틴은 즉시 실행하는 게 아니며, Thread와 다르게 OS의 영향을 받지 않아 그만큼 비용이 들어가지 않는다.")]),t._v(" "),a("li",[t._v("코루틴 전환시 Context Switch가 일어나지 않는다.")]),t._v(" "),a("li",[t._v("개발자가 직접 루틴을 언제 실행할지, 언제 종료할지 모두 지정이 가능하다.")]),t._v(" "),a("li",[t._v("이렇게 생성한 루틴은 작업 전환 시에 시스템의 영향을 받지 않아 그에 따른 비용이 발생하지 않는다.")])]),t._v(" "),a("p",[t._v("코루틴은 RxJava보다 좀더 완만한 곡선의 러닝커브를 자랑한다."),a("br"),t._v("\n기존 스레드로 하던 작업을 대부분 대체할 수 있을 뿐만 아니라 비동기 테스크의 생명주기를 컨트롤 할 수 있다는 것만으로도 큰 매력이라고 생각한다.")]),t._v(" "),a("h2",{attrs:{id:"getting-started"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#getting-started"}},[t._v("#")]),t._v(" Getting Started")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://github.com/Kotlin/kotlinx.coroutines",target:"_blank",rel:"noopener noreferrer"}},[t._v("kotlinx.coroutines"),a("OutboundLink")],1),t._v(" 에서 깃허브를 확인 할 수 있으며 아래로 설치 할 수 있다.")]),t._v(" "),a("div",{staticClass:"language-sh extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sh"}},[a("code",[t._v("implementation "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.7'")]),t._v("\n")])])])])}),[],!1,null,null,null);s.default=r.exports}}]);